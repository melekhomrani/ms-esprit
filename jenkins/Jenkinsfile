pipeline {
    agent any

    environment {
        NEXUS_URL = 'http://localhost:8081'
        NEXUS_REPO = 'maven-releases'
        NEXUS_CRED = credentials('nexus-credentials')
    }

    stages {
        stage('Build JARs') {
            steps {
                echo 'Building all microservices JARs...'
                sh 'mvn clean package -DskipTests'
            }
        }

        stage('Deploy JARs to Nexus') {
            steps {
                echo 'Deploying microservices JARs to Nexus...'
                sh 'mvn deploy -DskipTests'
            }
        }

        stage('Build and Run Authentication Service') {
            steps {
                echo 'Building and running authentication NodeJS service with injected credentials...'
                withCredentials([
                    string(credentialsId: 'KEYCLOAK_SERVER_URL', variable: 'KEYCLOAK_SERVER_URL'),
                    string(credentialsId: 'KEYCLOAK_REALM', variable: 'KEYCLOAK_REALM'),
                    string(credentialsId: 'KEYCLOAK_CLIENT_ID', variable: 'KEYCLOAK_CLIENT_ID'),
                    string(credentialsId: 'KEYCLOAK_CLIENT_SECRET', variable: 'KEYCLOAK_CLIENT_SECRET'),
                    usernamePassword(credentialsId: 'KEYCLOAK_CREDENTIALS', usernameVariable: 'KEYCLOAK_USERNAME', passwordVariable: 'KEYCLOAK_PASSWORD')
                ]) {
                    sh '''
                        export KEYCLOAK_SERVER_URL=$KEYCLOAK_SERVER_URL
                        export KEYCLOAK_REALM=$KEYCLOAK_REALM
                        export KEYCLOAK_CLIENT_ID=$KEYCLOAK_CLIENT_ID
                        export KEYCLOAK_CLIENT_SECRET=$KEYCLOAK_CLIENT_SECRET
                        export KEYCLOAK_USERNAME=$KEYCLOAK_USERNAME
                        export KEYCLOAK_PASSWORD=$KEYCLOAK_PASSWORD

                        docker-compose build authentication-app
                        docker-compose up -d authentication-app
                    '''
                }
            }
        }

        stage('Start Dependencies') {
            steps {
                echo 'Starting databases, Zookeeper, Kafka, and Keycloak...'
                sh 'docker-compose up -d keycloakdb keycloak productdb manufacturerdb zookeeper kafka'
            }
        }

        stage('Wait for Databases Ready') {
            steps {
                script {
                    waitForContainerHealth('keycloakdb', 'pg_isready -U keycloak')
                    waitForContainerHealth('productdb', "mongo --username root --password root --eval \"db.adminCommand('ping')\"")
                    waitForContainerHealth('manufacturerdb', 'mysqladmin ping -u root -proot')
                }
            }
        }

        stage('Wait for Zookeeper and Kafka Ready') {
            steps {
                script {
                    waitForLogReady('zookeeper', 'binding to port')
                    waitForLogReady('kafka', 'started')
                }
            }
        }

        stage('Wait for Keycloak Ready') {
            steps {
                script {
                    waitForHttpService('http://localhost:18080/health/ready')
                }
            }
        }

        stage('Build and Run Config Server') {
            steps {
                echo 'Building and running config-server...'
                sh 'docker-compose build config-server'
                sh 'docker-compose up -d config-server'
            }
        }

        stage('Wait for Config Server Ready') {
            steps {
                script {
                    waitForHttpService('http://localhost:8888/actuator/health')
                }
            }
        }

        stage('Build and Run Eureka Server') {
            steps {
                echo 'Building and running eureka-server...'
                sh 'docker-compose build eureka-server'
                sh 'docker-compose up -d eureka-server'
            }
        }

        stage('Wait for Eureka Server Ready') {
            steps {
                script {
                    waitForHttpService('http://localhost:8761/actuator/health')
                }
            }
        }

        stage('Build and Run Gateway') {
            steps {
                echo 'Building and running gateway...'
                sh 'docker-compose build gateway'
                sh 'docker-compose up -d gateway'
            }
        }

        stage('Wait for Gateway Ready') {
            steps {
                script {
                    waitForHttpService('http://localhost:8989/actuator/health')
                }
            }
        }

        stage('Build and Run Microservices') {
            steps {
                echo 'Building and running ms-product, ms-manufacturer, ms-notification...'
                sh '''
                    docker-compose build ms-product ms-manufacturer ms-notification
                    docker-compose up -d ms-product ms-manufacturer ms-notification
                '''
            }
        }
    }

    post {
        always {
            script {
                junit '**/target/surefire-reports/*.xml'
            }
        }
        success {
            echo 'Pipeline completed successfully. All services are built, deployed to Nexus, and running.'
        }
        failure {
            echo 'Pipeline failed.'
            mail to: 'melek@store.com',
                subject: "Jenkins Pipeline Failed: ${env.JOB_NAME} #${env.BUILD_NUMBER}",
                body: """\
                        The Jenkins pipeline for ${env.JOB_NAME} has failed.

                        Check details and console output:
                        ${env.BUILD_URL}

                        Action is required.
                    """
        }
    }
}

def waitForHttpService(url) {
    timeout(time: 3, unit: 'MINUTES') {
        waitUntil {
            script {
                def status = sh(
                    script: "curl -s ${url} | grep 'UP' || true",
                    returnStatus: true
                )
                return (status == 0)
            }
        }
    }
}

def waitForContainerHealth(container, checkCommand) {
    timeout(time: 3, unit: 'MINUTES') {
        waitUntil {
            script {
                def status = sh(
                    script: "docker exec ${container} ${checkCommand} || true",
                    returnStatus: true
                )
                return (status == 0)
            }
        }
    }
}

def waitForLogReady(container, logKeyword) {
    timeout(time: 3, unit: 'MINUTES') {
        waitUntil {
            script {
                def found = sh(
                    script: "docker logs ${container} --tail 20 | grep '${logKeyword}' || true",
                    returnStatus: true
                )
                return (found == 0)
            }
        }
    }
}
